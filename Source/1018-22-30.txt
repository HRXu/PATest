#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<cstdio>
#include<string>
#include<vector>
#include<algorithm>
#include<math.h>
#include<regex>
#include<set>
#include<map>
#include<queue>
using namespace std;
struct node{
    int id;
    int _count;
    int pre;
    int _cost;
}*v_node;
int capacity,stations_count,_end,edge_count;

int** adj;
bool *vis;
int *cost;
int *dis;
void dijkstra(int _start){
    vis[_start]=true;
    v_node[_start].pre=_start;
    for(int i=0;i<stations_count;i++){
        dis[i]=adj[_start][i];
        cost[i]=(capacity/2-v_node[i]._count);
        v_node[i].pre=_start;
    }
    for(int i=0;i<stations_count;i++){
        int _min=0x3f3f3f3f;
        int n;
        for(int j=0;j<stations_count;j++){
            if(!vis[j]&&_min>dis[j]){
                _min=dis[j];
                n=j;
            }
        }
        vis[n]=true;
        for(int j=0;j<stations_count;j++){
            if(!vis[j]&&dis[j]>dis[n]+adj[n][j]){
                dis[j]=dis[n]+adj[n][j];
                cost[j]=(capacity/2-v_node[j]._count)+cost[n];
                v_node[j].pre=n;
            }
            if(!vis[j]&&dis[j]==dis[n]+adj[n][j]){
                if(cost[j]>(capacity/2-v_node[j]._count)+cost[n]){
                    cost[j]=(capacity/2-v_node[j]._count)+cost[n];
                    v_node[j].pre=n;
                }
            }
        }
    }
}
bool cmp(const node&a,const node&b){
    if(a._cost<=0 && b._cost<=0){
        return abs(a._cost)<abs(b._cost);
    }
    return a._cost<b._cost;
}
int main()
{
    freopen("data.txt","r",stdin);
    cin>>capacity>>stations_count>>_end>>edge_count;

    stations_count+=1;
    v_node=new node[stations_count];
    adj=new int*[stations_count];
    vis=new bool[stations_count];
    cost=new int[stations_count];
    dis=new int[stations_count];
    for(int i=0;i<stations_count;i++){
        adj[i]=new int[stations_count];
        memset(adj[i],0x3f,sizeof(int)*stations_count);
    }
    memset(cost,0x3f,sizeof(int)*stations_count);
    memset(dis,0,sizeof(int)*stations_count);
    memset(vis,0,sizeof(bool)*stations_count);
    for(int i=0,j=1;i<stations_count-1;i++,j++){
        cin>>v_node[j]._count;
        v_node[j].pre=j;
    }

    for(int i=0;i<edge_count;i++){
        int a,b,c;
        cin>>a>>b>>c;
        adj[a][b]=adj[b][a]=c;
        adj[a][a]=adj[b][b]=0;
    }

    dijkstra(0);
    vector<node> _a;
    for(int i=0;i<stations_count;i++){
        if(i!=_end&&dis[i]+adj[i][_end]==dis[_end]){
            v_node[i]._cost=(capacity/2-v_node[_end]._count)+cost[i];
            v_node[i].id=i;
            _a.push_back(v_node[i]);
        }
    }
    sort(_a.begin(),_a.end(),cmp);
    v_node[_end].pre=_a[0].id;
    cost[_end]=_a[0]._cost;

    vector<int> res;
    int i=_end;
    while(v_node[i].pre!=i){
        res.push_back(i);
        i=v_node[i].pre;
    }
    res.push_back(i);

    printf("%d ",cost[_end]<0?0:cost[_end]);
    for(int i=res.size()-1;i>=0;i--){
        if(i==0){
            printf("%d ",res[i]);
        }
        else{
            printf("%d->",res[i]);
        }
    }
    printf("%d",cost[_end]<0?-cost[_end]:0);
    return 0;
}
